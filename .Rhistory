install.packages("R2jags")
install.packages("bridgesampling")
install.packages("babar")
library(bayesutils)
library(bayesutils)
library(coda)      # Handy utility functions like HPDIs
library(rstan)
# Extra options to set for Stan:
options(mc.cores = 4)
rstan_options(auto_write = TRUE)
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("exp_inv-gamma.stan"),collapse='\n')
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("/inst/stan_models/exp_inv-gamma.stan"),collapse='\n')
getwd()
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("inst/stan_models/exp_inv-gamma.stan"),collapse='\n')
# Translate Stan code into C++
model.c <- stanc(model_code = stan.code, model_name = 'model')
# Compile the Stan C++ model:
sm <- stan_model(stanc_ret = model.c, verbose = T)
# Data:
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
#Run the model:
fit <- sampling(sm, data = dat, iter=5000, thin = 1, chains = 4)
# Extra options to set for Stan:
options(mc.cores = 1)
#Run the model:
fit <- sampling(sm, data = dat, iter=5000, thin = 1, chains = 4)
print(fit)
traceplot(fit, pars=c("lambda"))
plot(fit)
# Examine the sampling output in more detail:
lambda <- extract(fit,"lambda")[[1]]
hist(lambda, bre=80, probability = T, xlim=c(0,1)) # Posterior for p.heads
hist(lambda, bre=80, probability = T) # Posterior for p.heads
cred <- 0.95
alp  <- 1 - cred
quantile(lambda, prob = c(alp/2, 1-alp/2))         # PI
HPDI(lambda, prob = cred) # HPDI
class(lambda)
credibility
library(bayesutils)
HPDI(lambda, prob = cred) # HPDI
HPDI(lambda, cred) # HPDI
quantile(lambda, prob = c(alp/2, 1-alp/2)) # Two-sided equal-tail PI
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
library(bayesutils)
#library(coda)      # Handy utility functions like HPDIs
#library(rstan)
library(bayesutils)
# Extra options to set for Stan:
options(mc.cores = 1)
rstan_options(auto_write = TRUE)
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("inst/stan_models/exp_inv-gamma.stan"),collapse='\n')
# Translate Stan code into C++
model.c <- stanc(model_code = stan.code, model_name = 'model')
# Compile the Stan C++ model:
sm <- stan_model(stanc_ret = model.c, verbose = T)
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("inst/stan_models/exp_inv-gamma_target_format.stan"),collapse='\n')
# Translate Stan code into C++
model.c <- stanc(model_code = stan.code, model_name = 'model')
# Compile the Stan C++ model:
sm <- stan_model(stanc_ret = model.c, verbose = T)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
#Run the model:
fit <- sampling(sm, data = dat, iter=5000, thin = 1, chains = 4)
print(fit)
traceplot(fit, pars=c("lambda"))
traceplot(fit, pars=c("lambda"))
traceplot(fit$lambda, pars=c("lambda"))
# Examine the sampling output in more detail:
lambda <- extract(fit,"lambda")[[1]]
traceplot(lambda, pars=c("lambda"))
rstan::traceplot(fit, pars=c("lambda"))
plot(fit)
# Examine the sampling output in more detail:
lambda <- extract(fit,"lambda")[[1]]
hist(lambda, bre=80, probability = T) # Posterior for p.heads
cred <- 0.95
alp  <- 1 - cred
quantile(lambda, prob = c(alp/2, 1-alp/2)) # Two-sided equal-tail PI
HPDI(lambda, cred)                         # HPDI
junk <- HPDI(lambda, cred)                         # HPDI
junk[1]
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
junk <- HPDI(lambda, cred)                         # HPDI
attr(junk)
attributes(junk)
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
HPDI(lambda, cred)                         # HPDI
?dimnames
source("~/codes/R/bayesutils/R/interval_utils.R")
library(bayesutils)
library(bayesutils)
library(bayesutils)
# Extra options to set for Stan:
options(mc.cores = 1)
rstan_options(auto_write = TRUE)
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("inst/stan_models/exp_inv-gamma_target_format.stan"),collapse='\n')
# Translate Stan code into C++
model.c <- stanc(model_code = stan.code, model_name = 'model')
# Compile the Stan C++ model:
sm <- stan_model(stanc_ret = model.c, verbose = T)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
#Run the model:
fit <- sampling(sm, data = dat, iter=5000, thin = 1, chains = 4)
print(fit)
traceplot(fit, pars=c("lambda"))
library(bayesutils)
# Extra options to set for Stan:
options(mc.cores = 1)
rstan_options(auto_write = TRUE)
# Load a Stan model:
#working.dir <- setwd("Desktop/")
stan.code   <- paste(readLines("inst/stan_models/exp_inv-gamma_target_format.stan"),collapse='\n')
# Translate Stan code into C++
model.c <- stanc(model_code = stan.code, model_name = 'model')
# Compile the Stan C++ model:
sm <- stan_model(stanc_ret = model.c, verbose = T)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
#Run the model:
fit <- sampling(sm, data = dat, iter=5000, thin = 1, chains = 4)
print(fit)
traceplot(fit, pars=c("lambda"))
plot(fit)
# Examine the sampling output in more detail:
lambda <- extract(fit,"lambda")[[1]]
hist(lambda, bre=80, probability = T) # Posterior for p.heads
cred <- 0.95
alp  <- 1 - cred
quantile(lambda, prob = c(alp/2, 1-alp/2)) # Two-sided equal-tail PI
HPDI(lambda, cred)                         # HPDI
library(bayesutils)
library(bayesutils)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
# Run the model
model_parameters <- c("lambda")
model_run = jags(data = model_data, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
dat <- list(
N     = length(fail.times),
t     = fail.times,
)
# Run the model
model_parameters <- c("lambda")
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
dat <- list(
N     = length(fail.times),
t     = fail.times,
)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times
)
# Run the model
model_parameters <- c("lambda")
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
alpha <- 1.5 # prior hyper-parameter
beta  <- 0.5  # prior hyper-parameter
# Run the model
model_parameters <- c("lambda")
alpha <- 1.5 # prior hyper-parameter
beta  <- 0.5  # prior hyper-parameter
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha <- 1.5, # prior hyper-parameter
beta  <- 0.5  # prior hyper-parameter
)
# Run the model
model_parameters <- c("lambda")
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
# Data:
fail.times <- c(0.2438356, 0.3917808, 4.7917808, 5.5561644, 0.2849315)
dat <- list(
N     = length(fail.times),
t     = fail.times,
alpha = 1.5, # prior hyper-parameter
beta  = 0.5  # prior hyper-parameter
)
# Run the model
model_parameters <- c("lambda")
model_run = jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
fit
fit <- jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
fit
# Run the model
jags.inits <- function() {
list(
lambda = runif(1, 0.01, 5)
)
}
params <- c("lambda")
fit <- jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
inits = jags.inits,
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
# Run the model
jags.inits <- function() {
list(
tau = 1/runif(1, 0.01, 5)
)
}
params <- c("lambda")
fit <- jags(data = dat, #inits = init,
parameters.to.save = model_parameters,
model.file = "inst/jags_models/exp_inv-gamma.bug.R",
inits = jags.inits,
n.chains = 4,
n.iter = 10000,
n.burnin = 1000,
n.thin = 10)
fit
plot(fit)
print(fit)
traceplot(fit)
fit$BUGSoutput$sims.array
fit$BUGSoutput$sims.matrix
fit$BUGSoutput$sims.matrix$lambda
fit$BUGSoutput$sims.matrix["lambda"]
fit$BUGSoutput$sims.matrix[lambda]
fit$BUGSoutput$sims.matrix[,"lambda"]
lambda <- fit$BUGSoutput$sims.matrix[,"lambda"]
traceplot(lambda)
traceplot(fir)
traceplot(fit)
R2jags::traceplot(fit)
hist(lambda, bre=80, probability = T) # Posterior for p.heads
cred <- 0.95
alp  <- 1 - cred
quantile(lambda, prob = c(alp/2, 1-alp/2)) # Two-sided equal-tail PI
HPDI(lambda, cred)                         # HPDI
